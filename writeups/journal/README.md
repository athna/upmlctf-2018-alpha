# Journal

Автор: [@nsychev](https://github.com/nsychev)

Электронный журнал с домашними заданиями для школьников на «самом перспективном языке программирования античности» (c) — Паскале.

### Как он работал?

Код компилировался под Mono компилятором [PascalABC.NET](http://pascalabc.net). Сервис был доступен на TCP-порту 1428.

Было два типа записей — пользователи (`TUser`) и домашние задания (`TAssignment`). Для авторизации и поиска домашних заданий использовались токены — случайные строки.

Чекер работает примерно так:

1. Регистрирует нового юзера
2. Получает токен
3. Добавляет от его имени задание (там и лежит флаг)
4. Получает код задания
5. Проверяет, что ему теперь доступен просмотр созданных им заданий («List my assignments»)
6. Регистрирует ещё одного юзера
7. Ищет задание по коду из пункта 4

Всё было бы хорошо, если бы не куча багов. Сервис был очень длинный, понять код было сложно. Однако, стоило начать с конца — ведь в паскале именно последний блок `begin .. end.` означает тело программы.

Можно было построить граф вызовов и из него уже понимать код. Однако, некоторые уязвимости можно было понять даже без чтения кода.

## Баг 0 — косяк с Mono

После сотни записей сервис безнадежно падал в `MUMBLE` из-за таймаута. К сожалению, оно правда работало медленно по той причине, что записи хранились в типизированных файлах, а они очень долго считываются.

Возможные решения:

- удалять записи старше 15 минут
- убрать .NET-зависимости и скомпилировать под Free Pascal
- переписать хранение на текстовые файлы
- оптимизировать проход по пользователям

Это был наш косяк, извините :( Дальше будут уже уязвимости в безопасности.

## Баг 1 — Нерандомные рандомные токены

В самом начале видно, что мы знаем о юзере. А знаем мы о нём немного — логин и статус.

Однако, при регистрации и авторизации используются некие токены. Становится интересно, откуда они берутся, и как мы валидируем пользователя, если не знаем его токен. В коде есть специальная функция — `VerifyUser`.

```pascal
function VerifyUser(user: TUser; token: string): boolean;
// check that token is correct for the user
begin
    result := token = SafeStringEscape(CryptoBlackBox(user.login, salt));
end;
```

Соответственно, токен проходит проверку, если он совпадает с `SafeStringEscape(CryptoBlackBox(user.login, salt))`. Видим, что `CryptoBlackBox` — это алгоритм Диффи-Адлемана (**чего?**), а `SafeStringEscape` — делает странный Hex из UTF-16 строки (именно в такой кодировке они в паскале по умолчанию).

Странным Hex получается из-за того, что алфавит не `0123456789ABCDEF`, а `24679BCFGKMPQSUW`.

Разберемся с шифрованием. Похоже, что алгоритм Диффи-Адлемана (которого, кстати, не существует) — это просто двухбайтовый xor логина (не однобайтовый, потому что один символ UTF-16 — это два байта).

Соответственно, результат зависит только от `salt`. Тут-то нас, наверное, и ждёт вся гениальность местной криптосистемы. И да, мы находим её в `Initialize`:

```pascal
var time: int64 = DateTimeOffset.UtcNow.ToUnixTimeSeconds() div 133731337 * 12345;
Randomize(time mod 2147483647);

// generating secure salt
var salt1, salt2: integer;
(salt1, salt2) := Random2(256);
salt := salt1 xor salt2;
```

Сначала мы инициализируем генератор псевдослучайных чисел сложной и **абсолютно криптостойкой** функцией, зависящей от времени, потом считаем два случайных числа от 0 до 255, и берем их xor (*по задумке автора, это должно было усиливать криптостойкость в два раза, но что-то пошло не так*).

И всё же, что это за функция? Мы берем unix timestamp (число секунд с 1 января 1970 года), делим нацело на 133731337 и умножаем на 12345. Выглядит действительно случайно. Однако, заметим, что в сутках 86400 секунд (24 × 60 × 60). Это значит, в течение одних суток значение нашей функции не меняется (так как timestamp делится нацело)!

Следовательно, хеши будут одинаковые для логина на любом вулнбоксе. Поэтому, например, можно сгенерить пароль у себя — а залогиниться у соперника.

Или просто написать прогу, которая генерит ключи, как и поступил я.

[Код эксплойта](nsychev_journal_passgen.py)

### Как закрыть?

Тупой способ закрыть — поменять сид рандома на другой

```pascal
Randomize(5646525236);
```

И это ломается ненамного сложнее. [Код эксплойта](nsychev_journal_staticseed.py)

### Как нормально закрыть?

Использовать случайный сид и хранить токен в записи:

```pascal
TUser = record
    login: string[50];
    status: integer;
    token: string[50];
end;

...

Randomize;
```

## Баг 2 — чужие «мои задания»

Создадим юзера и задание от его имени. Посмотрим в «List my assignments». Видим... много заданий! Откуда они взялись? Ответ прост — статический анализатор в мозгу разработчика сервиса решил, что лишние условия не нужны, и закомментировал строку 324, которая проверяет, является ли пользователь владельцем заметки.

```pascal
procedure ListMyAssignments();
// list of user's assignments
begin
    foreach assignment: TAssignment in assignments do
        // if assignment.teacher = user.login then
            WriteLn('#', assignment.key);
    Flush(output);
end;
```

Так мы получаем ключи от всех заданий.

[Код эксплойта](nsychev_journal_my_ass.py)

### Как закрыть?

Раскомментировать строку.

## Баг 3 — Elite status

В некоторых местах функционал сервиса зависит от нашего «статуса». При регистрации он равен нулю, после создания первого задания — единице. Однако, в некоторых местах кода для пользователя со статусом 1337 есть некоторые пасхалки — например, функция, выводящая список всех заданий (на кнопке `5`).

Но пользователей с таким статусом нет! Если мы выведем список и переберем всех, ни у одного пользователя дополнительное действие не появляется. Да и нельзя нигде (кроме добавления задания) поменять себе статус.

Однако, посмотрим внимательнее на функцию вывода списка пользователей:

```pascal
procedure ListUsers();
// list of all users
begin
    foreach user: TUser in users do
        if user.status < 1337 then
            WriteLn(user.login);
    Flush(output);
end;
```

Она затирает пользователей со статусом 1337 так, чтобы их логины никто не увидел.

Что ж, пора написать свой код на паскале, читающий всех пользователей из `users.dat`. Это сделать несложно, учитывая то, что у нас уже есть куски кода из сервиса:

```pascal
type
    TUser = record
        login: string[50];
        status: integer;
    end;

function ReadFile<T>(fileName: string): array of T;
begin
    try
        result := ReadElements&<T>(fileName).ToArray();
    except
        SetLength(result, 0);
    end;
end;

begin
    foreach user: TUser in ReadFile&<TUser>('users.dat') do
        WriteLn(user.login, ' ', user.status);
end.
```

И что бы вы думали? Первой строкой он выводит пользователя с логином `userlist` и искомым статусом!

Используя это совместно с первым багом, логинимся и забираем все флаги.

[Код эксплойта](nsychev_journal_superuser.py) (*за основу взят эксплойт `staticseed` — он работает даже если поменять сид рандома*)

### Как закрыть?

Очевидно, что этот юзер является простым бекдором, так как через него всегда можно вытащить все флаги.

Можно удалить юзера и вообще весь функционал юзеров с правами 1337.

## Баг 4 — Race condition

Каждый раз, когда мы открываем коннект к серверу, список пользователей читается из файла.

Давайте подключимся к серверу, не будем входить, и подождем, пока новый пользователь зарегистрируется и положит флаг.

Заметим, что в нашем экземпляре сервиса пользователя в базе всё ещё нет (она уже прочитана из файла). Значит, мы можем зарегистрировать такого же пользователя, получить токен для входа (и уже этот токен попадет в файл!), после чего подключиться заново и с полученным токеном получить флаг.

[Код эксплойта](nsychev_journal_race.py)

### Как закрыть?

Можно читать файл непосредственно перед попыткой логина. Однако, лучше всего использовать какую-нибудь базу данных, хотя бы SQLite. Их не поддерживает нативно сам Паскаль, однако, можно пользоваться соответствующими инструментами в .NET

## Мораль и всё такое

Этот сервис, как и его разбор, был самым сложным и длинным на нашем цтфе :)

Я бы мог сказать, что не стоит писать промышленный код (да и вообще всё) на Паскале, но это не главное.

На самом деле, данный сервис наглядно показывает, к чему приводит написание своих велосипедов и костылей — использование типизированных файлов вместо базы данных, кастомное шифрование, реализация операций с базой без ORM.

Для всего, что было в этом сервисе, существуют готовые инструменты (типа баз данных и функций шифрования), и их стоит использовать.

На этом всё :)

